---
title: "Translate your text while you are sleeping!"
author: "Vladimir Zhbanko"
output: html_notebook
---

# Automatic Translations with R and Google Translator API

This document is to create a way to easier read and translate captions in `*.vtt` format

## Section 1 Why do you need it?

### Lecture 1 Introduction

Hello and welcome to the course! 

This course is about **automating your translation jobs with Google Translate API**. We will access it via R Software for Statistics and Graphics. This way we coud use this course even for more anvance text processing or even sentiment analysis. With R we can do all that while not being professional programmers

This short but powerful course will teach you how to turn your computer into the text translating machine!!!

It will be valuable for you for a number of reasons. Primary goal will be to translate **closed captions files** for online videos. However you can also apply this course if you are dealing with documents that needs to be translated to many different languages. For example **product manuals or operating instructions**. In case the content of the documents may change over time your ability to shorted translation process can greatly **shorten time to market**. You may also need to perform **sentiment analysis of foreign text** like specific consumer database or twitter feeds, hence the course may be helpful for data pre-processing steps.

This **course is short and sweet**. I don't have much time to create long lectures so you don't have time to watch them. If you joining the course this is because you want to automate your translating jobs. You want to do this fast. Inspite the course is short **you will have many useful examples** to learn. For example text manipulation in R, dataframe manipulations, reading and manipulating files and more. Our primary objective will be to see how can you translate VTT files used for closed captions. In our example you will see how we would be able to set up a job capable to process 23 files and translate them to 8 different languages. You will see exactly all steps we do and you will be able to follow along and repeat them.

Google Translate web page is free service, **Google translate API is not free**. Great news is that **you can have free trial** period and you could be able to start right away without paying a dime. Additionally course will **allow you to estimate approximate cost** of translation should you want to use it on a constant basis.

Before I forgot let me tell you one **additional advantage** of the course. This course will take usage of API keys very seriously. You will be able to learn how can you **encrypt your API key**. This way you will even be able to store your R scripts in the public version control repositories... 

So join this course because you will be able to automate your translation and let computer do the job!


```{r}
citation()
```


In the next few minutes I would like to introduce to the whole list of guide you through the course to 


* many files to translate
* automate repetitive tasks
* good quality initial text

## Section 2 Make It!

### Lecture 2 Install R

Re-use lecture about R installation

### Lecture 3 Google Translator API key

* Subscribe to Google Cloud Platform
* Generate your API Key
* Copy your key

Hello and welcome back to the course. 
In this lecture we will talk about Google Cloud Platform. We will have a very brief overview of the platform and most importantly we will generate an API key in order to use Google Translate API

Just to repeat the concept. Google translate web page is simple and free. Google Tranlate API allow you to automatically send text process it and send you translation back. This is a paid service but eventually you can get first 12 month free trial and 300 USD credit to use for your practice.

There are two ways to get there. The first one is to go to code.google.com. Click on developers tab and scroll down to the bottom. You will find the tab Google Cloud Platform. Alternatively you can type directly cloud.google.com. First time connecting you will need to subscribe for the free trial. I have already done so. All I needed is to provide a credit card number, and my billing information. The great thing is that they would not charge you if you overrun your limit within the trial period. You will have a chance to cancel subscription. Feel free to explore this web page. it is containing a lot of stuff. Imagine hundreds of engineers are working on that! But don't get lost
Finally click on Go to Console. You will go to the project environment. Whre you have your dasbhoard. The most importan part is Billign Menu. Let's go there. See that I have 275 Swiss franks remaining here. Next click on the menu and select API and Services. Click on the Library and search for Google Cloud translation API. Select it and click on Manage. We will however need just the API Key which you can get going to Credetnials menu. Simply click and choose generate credentials. You can have a chance to restrict it by IP address for example. I will name my key to remember and that is it!

So this is all really that we need - we get now our Key! But keep it there, don't write it on the paper. We will learn how to handle it in the next lecture. If you are not, you will learn how to encrypt this key!

happy translating!













































### Lecture 4 Encrypt your key in R!

Hello and welcome back to the course. 

As you already noticed API key is the same as your password from online banking. You have to protect it. This is what we will do in this lecture!

By the way I have made dedicated course that teach in detail about how to use Public key Cryptography in R Statistical Software. Especially for the students of this course - check out the last lecture as you may find a coupon there! **Cryptography is more fun with R!** [course coupon](https://www.udemy.com/keep-your-secrets-under-control/?couponCode=KEEP-SECRET-20) This solution course will give you a basis and more importantly practical solutions with great understanding of the process. By the way, this course subtitles were translated to 8 languages! This time I will give you a solution how you can encrypt your key without much explanations. However for your better clarity let me show you this illustration. What we will do in the moment is to create a hidden folder and generate our private and public keys. We will be able to encrypt our API key and keep it encrypted in our R folder. Having done this you may easily decrypt this key when you using it as well as keep entire project in the Version Control repository.

Let's now go to R adn load libraries. Openssl library is needed to use Cryptography and tidyverse library is needed to perform data manipulations. The code you see here is needed to generate our private key. You will want to adapt the path to correspond to your folder structure. In this case I am creating a private key and write it to our folder. I am also extracting a public key from my private key and also store it in the same folder. 

Finally we are ready to encrypt our API key. Open your browser and open cloud.google.com. Go to Console. In your project select menu and click on API and services. Click on Credentials and find your key. Simply copy this key, paste and run this code. This code will serialize your text string into numbers and then use your public key to encrypt it. Finally we will write the result of the encryption into our project directory.

If you have a file with extension rds that is R data structure you are ready to move to the next exciting lecture where we will start translating. I am looking forward to meet you there

happy translating!

It is highly recommended that you encrypt your key! This lecture will show how. Remember that you can learn much more about using Cryptography from my other course **Cryptography is more fun with R!** [course coupon](https://www.udemy.com/keep-your-secrets-under-control/?couponCode=KEEP-SECRET-20)

#### Using Public Key Cryptography to securely store your API Key

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=TRUE}
# Generate your private key and write it to the folder, we assume you will save it to the folder C:/Users/UserName/.ssh/ mac users can adapt the path...
# if necessary install package
# install.packages("openssl"); install.packages("tidyverse")
# loads library open ssl and tidyverse
library(openssl)
library(tidyverse)

# generate private key
rsa_keygen(bits = 5555) %>% write_pem(path = "C:/Users/fxtrams/.ssh/id_api")
# extract and write your public key
read_key(file = "C:/Users/fxtrams/.ssh/id_api", password = "") %>% `[[`("pubkey") %>% write_pem("C:/Users/fxtrams/.ssh/id_api.pub")

```






























Now you have your personal public key which we will use to encrypt the credentials

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
# encrypt your key (I am showing my API key because I will delete it anyhow after creating the course)
## Encrypt with PRIVATE key (e.g. use this code yourself)
"AIzaSyBOoesHv7_7Sd3hYDTNVW3v_8IBpza-_j8" %>% 
  # serialize the object
  serialize(connection = NULL) %>% 
  # encrypt the object
  encrypt_envelope("C:/Users/fxtrams/.ssh/id_api.pub") %>% 
  # write encrypted data to File
  write_rds("api_key.enc.rds")

```

Now we have our encrypted key inside our project folder! 

If you will use this script later -> delete API key from your script and feel free to use Version Control Repository!

In the next lecture we will see how to read the key back!

**NOTE:** if you plan to collaborate and use your key by multiple persons with version control check out R package 'secret'. Remember that you can learn how to use it in my course about Cryptography in R!

































### Lecture 5 Translate Hello World!

In this lecture we will finally start translating! We will see how to use package in R called **translate**. Think about it as a program that was already prepared for you. This program will connect to google send the text there and will bring back the result to you. To install this package you can run the code install.packages("translate"). This package was created by Peter Danenberg. Remember that you can always see a help of the package by running the code question mark translate. All that this package need is our text, the notion from which to which languages to translate it and the API key. For that we will need to decrypt our API key first. We will load package openssl once again here. We will read our encrypted object. Then we will use function decrypt envelope and unserialize to return our API key back. Remember to adapt your the path to your .ssh folder and simply run provided code. Finally we can use this package. Let's first translate something simple like Hello world into German. Yes it works. Now let's play a bit and write something different. Let's translate from italian to english Mi Piace questo corso. It works! This was very simple preparation lecture. We just need it to know the basis before we go to the next step. In fact in the next section we will start translating closed captions files from english to many other languages!

I hope you able to follow the concepts on your own and looking forward to wait you in the next lecture. Happy translating!

```{r}
library(openssl)
library(tidyverse)
# to install package in R
#install.packages("translate")
library(translate)
citation("translate")

```




```{r}
# help on the package
#?translate

# we need our API key to translate 
out <- read_rds("api_key.enc.rds")

# decrypting the password using public data list and private key (optional!)
api_key <- decrypt_envelope(out$data, out$iv, out$session, "C:/Users/fxtrams/.ssh/id_api", password = "") %>% 
  unserialize()

# usage: translate(query, source, target, key = get.key())
translate("I like this course", "en", "de", key = decrypt_envelope(out$data, out$iv, out$session, "C:/Users/fxtrams/.ssh/id_api", password = "") %>% 
  unserialize()) 

# you can detect source language of the text
detect.source("Mi piace questo corso", key = api_key)

# list of valid language mappings
languages(key = api_key)

translate("Как насчет выпить", "ru", "en", key = decrypt_envelope(out$data, out$iv, out$session, "C:/Users/fxtrams/.ssh/id_api", password = "") %>% 
  unserialize())

translate("How about a drink", "en", "ru", key = decrypt_envelope(out$data, out$iv, out$session, "C:/Users/fxtrams/.ssh/id_api", password = "") %>% 
  unserialize())


```


























## Lecture 6 Solving Translation problem for one VTT file

Solving for one file. Reading the file and visualizing the object

```{r}
# read file -> it will be a dataframe
t <- read.delim("C:/Users/fxtrams/Downloads/L0.vtt", stringsAsFactors = F)
t
```





































Extract logical vector identifying position of the arrow '-->'
Get only piece of table with text and with timestamps

```{r}
library(tidyverse)
# extract logical vector indicating which rows containing timestamps
x <- t %>% 
  # detect rows with date time (those for not translate)
  apply(MARGIN = 1, str_detect, pattern = "-->")

# extract only rows containing text (e.g. not containing timestamps) 
txt <- subset.data.frame(t, !x) 
# extract only time stamps
tst <- subset.data.frame(t,  x)
```

























Translating this file.
We will need to read API key first
Selecting one column and giving it the original name

```{r}
library(translateR)
library(openssl)
citation("translateR")
# get back our encrypted API key
out <- read_rds("api_key.enc.rds")
api_key <- decrypt_envelope(out$data, out$iv, out$session, "C:/Users/fxtrams/.ssh/id_api", password = "") %>% 
  unserialize()
# translate object txt or file in R
# Google, translate column in dataset
google.dataset.out <- translate(dataset = txt,
                                content.field = 'WEBVTT',
                                google.api.key = api_key,
                                source.lang = 'en',
                                target.lang = 'es')

# extract only new column
trsltd <- google.dataset.out %>% select(translatedContent)

# give original name
colnames(trsltd) <- "WEBVTT"
```


































Join timestamps with translated text
Order dataframe

```{r}
# bind rows with original timestamps
abc <- rbind(tst, trsltd)

# order this file back again
bcd <-  abc[ order(as.numeric(row.names(abc))), ] %>% as.character() %>% as.data.frame()
```







































Add empty row 
Write to the file...

```{r}
# return original name
colnames(bcd) <- "WEBVTT"

bcd <- as.tibble(bcd)
# add one row
bcd2 <- add_row(bcd, WEBVTT  = "", .before = 1)

# write this file back :_)
write.table(bcd2, "translated.vtt",quote = F, row.names = F, fileEncoding = "UTF-8")
```

































Hello and welcome back to the course. In this section we are going to complete translation task. The task will consist in translating vtt files. these are the files that have special structure and allowing to overlay closed captions in our videos. Task is not about translate one file to one language but to translate 23 files into 8 different languages. Important note is that original files to translate is already properly reviewed and english translation was already corrected.
In particular in this lecture we will review how to solve this problem for one file. We will move a bit slow trying to understand what is happening. Along the way we will have to make some string manipulations we will learn how to read and write files from R and we will learn about new pacakge in R that will help us to translate text in dataframes. Finally we will have a fully translated and functioning VTT file. If you don't need this knowledge and prefer to go directly to the final result, feel free to move to the following lectures of the course.

Let's go and make it for one file first... Let's first of all simply open this vtt file. I will be using Notepad ++ here. The file has a identifier on top then it has a space, following next there are time stamps identifying position of the text and the text itself. To read this file in R I will use base function read.delim(). I will give a path to the file and say that I want to load strings of text as characters. I will assign this file to the object 't'. Let's review what we have... well it's a dataframe table with one column. Every second column acutally contains text and this text we need to translate. My idea will be to detect rows of this data frame that containing element with arrow. I will then subset or extract only rows containing text. 

To move forward I will use library tidyverse. I will take dataframe and apply function string detect on the pattern with arrow. MARGIN argument set to 1 means that we will apply this function to each row. Now the object x will contain logical vector and TRUE will mean that corresponding row of the dataframe is containing the arrow. Finally we can subset two objects. One containing timestamps and another containing rows with text. Let me just view these objects. Great that is what we wanted.

Next big thing we will do is to translate it. As you remember in the previous lecture we were using package translate. This time we will use package translateR. This package works exatly same but it allows further improvements. It will work both with google and microsoft as well as it will return the dataframe object directly. We will read our encrypted API key. Next we will pass the dataframe containing text, we specify which column we want to translate, we also specify source and destination languages accordingly. After running this function we are getting our dataframe which now contains two columns. One with original text and another one is the translated one. 

We will now extract only column with translation and give it original column name... We have our translated content but we still need to join the piece of table with our timestamps. For that I will use function to bind rows. If I see my new object I can see that all that we need is to arrange it by row names. I will use function order for that. Almost there. 

Somehow we missed our name of the column so I will give it back. Also I will add one empty row with function add row. Final step is to simply write this file specifying that we don't want quotes and row names. Perhaps a bit of cumbersome but it works and we achieved our goal. In fact we have our file translated and it's in perfect order ready to be used for closed captions. Now we certainly made a great mess, we generated a lot of objects just to understand how things are working! Let's make an order in the next lecture and pack our code into R function! Until then, happy translating!















## Lecture 8 Pack code into Function

Hello and welcome back to the course. In the last lecture we have made quite a mess. In fact we generated a lot of intermediate objects. But it's all right. In fact this is a great benefit of R programming language allowing you experiment and finding your way to do things. But let's remember that we have 23 files and 8 or more languages. We can't possibly copy and paste our code for each file. For this we will place all this code into function. I have already wrote this function and you can see it here.

This function contains everything from our previous lecture. However what you see is different is presence of generic arguments. For example file name, source and destination languages will allow us to re-use this function for different files and languages!

Let's see this function in action! Because my function is saved into R script I am able to call it with a command source. For the demonstration let me translate the original file into Dutch! I can simply provide the path to the file, give it a languages and api_key. That's it! It's perfectly works the file with translation is fully ready!

Enough words, let's jump to the next lecture were we will use this function to translate our 23 files to 8 different languages!



































```{r}
# call our translation function from R script to environment
source("translateVTT.R")

translateVTT(fileName = "C:/Users/fxtrams/Downloads/L0.vtt", 
             sourceLang = "en",
             destLang = "nl",
             apikey = api_key)
```











































```{r}
library(translateR)

# read file -> it will be a dataframe
t <- read.delim("C:/Users/fxtrams/Downloads/L3.vtt", stringsAsFactors = F)

# extract logical vector indicating which rows containing timestamps
x <- t %>% 
  # detect rows with date time (those for not translate)
  apply(MARGIN = 1, str_detect, pattern = "-->")

# extract only rows containing text (e.g. not containing timestamps) 
txt <- subset.data.frame(t, !x) 
# extract only time stamps
tst <- subset.data.frame(t,  x)

# # write to file for translation (manually)
# txt %>% write.table("translate.txt", row.names = F)

# # write lines for translations
# lns <- txt %>% as.matrix() %>% c()
```

## translate this file using translate API paid service in Google

```{r}
# translate object txt or file in R
# Google, translate column in dataset
google.dataset.out <- translate(dataset = txt,
                                content.field = 'WEBVTT',
                                google.api.key = "api key do not check me in to Version Control!",
                                source.lang = 'en',
                                target.lang = 'es')

# extract only new column
trsltd <- google.dataset.out %>% select(translatedContent)

# give original name
colnames(trsltd) <- "WEBVTT"

# 
```

## place it back...

```{r}
## read this file back
#tsltd <- read.table("translate.txt", encoding = "UTF-8", header = T, stringsAsFactors = F)

# add original row names to the table tsltd
# row.names(tsltd) <- as.numeric(row.names(txt))

# bind rows with original timestamps
abc <- rbind(tst, trsltd)

# order this file back again
bcd <-  abc[ order(as.numeric(row.names(abc))), ] %>% as.character() %>% as.data.frame()

# return original name
colnames(bcd) <- "WEBVTT"

bcd <- as.tibble(bcd)
# add one row
bcd2 <- add_row(bcd, WEBVTT  = "", .before = 1)

# write this file back :_)
write.table(bcd2, "translated.vtt",quote = F, row.names = F)


```





## Lecture 8 For loop!

Hello and welcome back to the course. This lecture I am recording during real usage of this code! My goal is to automate my function and finally translate my 23 files to 8 different languages!!! Obviously along the way we will learn how to write for loops in R. Let's see my original files. I have here 23 files and each contains subtitles for my video lectures. I can open one to show you. We know how this file is built, we know how to translate each one automatically. My plan will be to apply function to each file and for each desired language. We will start by loading our function from file to R environment. 
Next I will load packages openssl and tidyverse. Next I will generate a character vector containing names of the files I have in my folder. This folder contains my files to translate. Just to make things clear I can visualize this vector and see all the filenames here. Next thing I will do is to write a vector containing symbols of my languages I want to translate to. After than I will execute lines of code neceassary to decrypt my api key. Now the most interesting part is starting. I will simply write word 'for'. Just wait a second and R Studio will bring you the code scheleton. Let's define variable to be FILE and choose the vector that is named files to translate. This for loop will execute specific code for each our file! Inside this for loop we will obviously need to create one more for loop. Again we type word for and I will create varialbe LANG for the vector languages. Pause the video now and think what should follow next. Next part will be of course our function. Try to pause the video again, take piece of paper or complete this code by yourself. Of course we will provide FILE as our filename, LANG as our destination language and the rest does not really changes. Before we will run this for loop I will do couple of other things. First I will record the starting and ending time of this code execution. I will use function System time and save resutls to the variables. Let me now show you that it's late... now I will just duplicate to know the ending time of the code. 

Second thing I will do I will go to my Cloud account to see how much money I have before running this function. In fact I have 275.03 swiss frank remaining. I will record this amount to the variable balance before. and finally We are ready to run our code!!! Obvously let me please remind you the name of the course. In fact I will be going to sleep now and computer will be translating it! When I will wake up we will conclude and learn how much will this automation costs to us! Until then happy translating!

## Lecture 9 How much does it cost?

Hello and welcome back to the the course. 

In this lecture We will see the result of translation and conclude by reviwing how much it costed to us both in terms of time and money. I would also briefly mention how can you benefit from the Automated Translation API from google because it is relly worth it! Additionally we will see how it's possible to delete our API key in case we will not planning to use it for a next time. 

Let me go and see first what is in the folder containing results. Super, I have all my files perfectly translated. Each filename has been marked with a text index so I know which file means which language. It would be of course possible to create separate folders for each of our languages. If you feel need it please post a question in the course board and I will gladly create you a bonus lecture for you. 

Now let me go back to my R software to see how much time did it take. Good news that I can simply substract end time from start time and I will be able to learn that it took one and the half hour. What about money? Do I still have any money left? I will go to my project and I will learn that I have 256 CHF remaining. Which is probably not too bad. Considering time it would take me to translate all those files manaully 20 swiss franks are not that big deal. Even if you have to pay that from your own pocket it is still worth to use automated translation. Just remind that we have now 8 different languages and in total we have generated 184 translated files. That is equivalent to 10 cents for one! Additionally we could totally automate our job so it would definitely pay off if you do translation professionally! I can tell you more. Even if I had free time I would be extremely bored to manually move trough each file and translate it... 

In this course we have solved a problem of translating VTT files. However let me spend few moments about discussing how else you can benefit from this course? Let's assume you work for a company that needs to export products to many countries. Obviously you will be obliged to build user instructions for your product. Exactly, you probably already got my idea. You have your original master instruction. Perhaps each topic is saved in the database and you can easily translate your text to any languages! If your master instruction changes over different product revisions you will be able to simply re-run your translation job and all the translations will be updated accordingly! You can probably cut the time to market virtually to hours instead of weeks...

There are probably many other use cases, feel free to discuss them in the course question board...

Let me now move to the last chapter of the lecture. I will just remind you that API key is linked to your billing account with google. For that it would be wise to delete your key. Well It's very  intuitive. Simply go ahead and delete it. Because of the fact that you can generate your key any time again it's probably better delete it so you don't need to worry about it. 





So thank you for be part of the course and happy translating!


```{r}
# translate 23 files in .vtt format
source("translateVTT.R")
library(openssl)
library(tidyverse)

# make a list of files to translate
filesToTranslate <-list.files("C:/Users/fxtrams/Downloads/", pattern="*.vtt", full.names=TRUE)
# make a list of languages
languages <- c("fr", "tr", "it", "id", "pt", "es", "ms", "de")
# get api key
out <- read_rds("api_key.enc.rds")

# decrypting the password using public data list and private key
api_key <- decrypt_envelope(out$data, out$iv, out$session, "C:/Users/fxtrams/.ssh/id_api", password = "") %>% unserialize()

# starting time of my job
start_time <- Sys.time()
balance_before <- 275.03

# for loop
for (FILE in filesToTranslate) {
  # for loop for languages
  for (LANG in languages) {
    # translation
    translateVTT(fileName = FILE, sourceLang = "en", destLang = LANG, apikey = api_key)
  }
  
}


# starting time of my job
end_time <- Sys.time()

# how much time did it take?
end_time - start_time
# balance
balance_after <- 256.66

# total cost
cost <- balance_before-balance_after

cost

# result:


```
# conclusion!
1.26 hours and 18.37$ to translate 23 files to 8 different languages...






























# billing
https://console.cloud.google.com/billing/01B83E-7B64EC-1DD123

```{r}
# translate all courses
source("translateVTT.R")
library(secret)
library(openssl)
library(tidyverse)

# make a list of files to translate
filesToTranslate <-list.files("C:/Users/fxtrams/Downloads/", pattern="*.vtt", full.names=TRUE)
# make a list of languages
languages <- c("fr", "tr", "it", "id", "pt", "es", "ms", "de")
# get api key
api_key <- get_secret("api_google_Translate", key = "C:/Users/fxtrams/.ssh/id_api", vault = "COMMON")

# for loop that translate all languages!
for (fl in filesToTranslate) {
  # another for loop for languages
  for (la in languages) {
    translateVTT(fl, "en", la, api_key)
  }
  
}


```


